
#' Return the reverse compliment for a DNA sequence
#' @keywords internal
rev_comp = function(x){
  return(seqinr::c2s(rev(seqinr::comp(seqinr::s2c(x)))))
}


#' Look for triple inserts in the PHMM path.
#' @keywords internal
triple_ins = function(x, path_start, path_end){
  inserts = c(path_start:path_end)[x[path_start:path_end] == 0]
  triples = c()
  if(length(inserts) > 2){
    for(i in 1:(length(inserts)-2)){
      potential = inserts[i]:(inserts[i]+2) 
      observed = inserts[i:(i+2)]
      if(isTRUE(all.equal(potential, observed))){
        triples = c(triples, observed)
      }
    }
    return(triples)
  }else{
    return(c())
  }
  
}

#' Adjust the DNA sequence based on the ntPHMM path
#'
#' @param frame_dat The DNAseq's framing data - generated by set_frame()
#' @param path_out The nucleotide PHMM path for the sequence.
#' @param censor_length number of base pairs in either direction of a PHMM correction
#' to convert to placeholder characters 
#' @keywords internal
adj_seq = function(frame_dat, path_out, censor_length = 3){
  
  org_seq_vec = frame_dat$trimmed_seq
  #or pass in the bin value and use:
  #org_seq_vec = as.character(org_seq)[[1]]
  
  # build a new sequence from scratch
  #note: the front of the sequence (leading dashes)
  #is not added until the last line, after adjustment and censorship
  #this is to prevent the dashes from shifting the frame and causing the 
  #positions of all of the corrections to have to be adjusted
  new_seq = c()
  #start at the first positon in the path
  org_seq_pos = 1
  path_pos = frame_dat$path_start
  path_end = frame_dat$path_end
  new_pos = 1
  
  censor_0s = c() #these were deleted from true seq  
  censor_2s = c() #these were inserted into true seq
  match_seen = FALSE

  #adjustments to skip because they occur as a codon
  triple_inserts = triple_ins(path_out, path_pos, path_end)

  for(i in path_pos:path_end){
    #this prevents additions beyond the end of the original sequence.
    if(org_seq_pos > length(org_seq_vec)){
      break
    }
    #0 = D
    if(path_out[i] == 0){
      #there was a bp missing in the original seq
      #add a placeholder to the new seq, don't advance on original pointer
      
      #NOTE: this is to truncate the sequence if a large string of
      #gap characters is encountered, this prevents incorrect additions
      #The information is not discarded, but rather added to an
      #additional part of the output vector, so that it can be recovered if
      #the edges of the sequences are not being removed
      if(paste(path_out[i:(i+4)], collapse='') == "00000"){
        break        
      }
      #NOTE: this if clause is to prevent addition of an extra placeholder
      #in cases where adjust seq has already added a placeholder
      if(match_seen == TRUE){
        #only make the placeholder addition if the 
        #the 0 in the path is not found as a member
        #of a triple, these are missing codons and likely true
        if(!i %in% triple_inserts){
          new_seq = c(new_seq, '-')
          
          new_pos = new_pos + 1
          
          censor_0s = c(censor_0s, new_pos)
        }
      }
      
      #1 = M
    }else if(path_out[i] == 1){
      new_seq = c(new_seq, org_seq_vec[org_seq_pos])
      org_seq_pos = org_seq_pos + 1
      
      new_pos = new_pos + 1
      match_seen = TRUE
      
      #2 = I
    }else if(path_out[i] == 2){
      if(match_seen == TRUE){
        #if there is a large run of 2s then cease the adjustment loop, sequence if
        #off the rails and should not be adjusted further
        if(paste(path_out[i:(i+4)], collapse='') == "22222"){
          break        
        }
      
        #there was a bp insertion, skip this bp in the original seq
        org_seq_pos = org_seq_pos + 1
        
        censor_2s = c(censor_2s, new_pos)
      }
    }

  }
  
  if(org_seq_pos < length(org_seq_vec)){
    trimmed_end = org_seq_vec[org_seq_pos:length(org_seq_vec)]
  }else{
    trimmed_end = c()
  }
    
  if(censor_length != 0){

    #censor_0s
    if(!is.null(censor_0s)){
      censor_0s_masks = unlist(lapply(censor_0s, function(pos){
        (pos-censor_length):(pos+censor_length)
      }))		
      censor_0s_masks = unique(censor_0s_masks)
      censor_0s_masks = censor_0s_masks[censor_0s_masks>0]
      censor_0s_masks = censor_0s_masks[censor_0s_masks<=length(new_seq)]
      
      new_seq[censor_0s_masks] = "-"
      
    }
    #censor_2s
    if(!is.null(censor_2s)){
      censor_2s_masks = unlist(lapply(censor_2s, function(pos){
        (pos-(censor_length-1)):(pos+censor_length)
      }))
      censor_2s_masks = unique(censor_2s_masks)
      censor_2s_masks = censor_2s_masks[censor_2s_masks>0]
      censor_2s_masks = censor_2s_masks[censor_2s_masks<=length(new_seq)]
      
      new_seq[censor_2s_masks] = "-"		
    }
  }

  adj_count = length(c(censor_0s,censor_2s))
  
  return(list(c(frame_dat$front, new_seq), adj_count, trimmed_end))
}

#c(new_seq, trimmed_end) == org_seq_vec

#' Adjust the sequences based on the nt path outputs.
#'
#' @param x a DNAseq class object.
#' @param ... additional arguments to be passed between methods.
#' @param censor_length the number of base pairs in either direction of a PHMM correction
#' to convert to placeholder characters. Default is 3.
#' @return a class object of code{"ccs_reads"} 
#' @seealso \code{\link{DNAseq}}
#' @seealso \code{\link{frame}}
#' @examples
#' #' #previously called
#' ex_data = DNAseq(example_nt_string, name = 'SSGBC787-14')
#' ex_data =  frame(ex_data)
#' #adjust the sequence with default censor length is 3
#' ex_data = adjust(ex_data)
#' #with a custom censorship size
#' ex_data = adjust(ex_data, censor_length = 5)
#' @export
#' @name adjust
adjust = function(x, ...){
  UseMethod("adjust")
} 

#' @rdname adjust
#' @export
adjust.DNAseq = function(x, ..., censor_length = 5){
  
  adj_out = adj_seq(x$frame_dat, x$data$path, censor_length = censor_length)

  x$adjusted_sequence = adj_out[[1]]
  x$adjustment_count = adj_out[[2]]
  x$data$adjusted_trimmed = adj_out[[3]]
  return(x)
}



#' Get the final denoised output sequence for a read.
#'
#' 
#' @param x a DNAseq class object.
#' @param ... additional arguments to be passed between methods.
#' @param keep_flanks Default is TRUE.
#' @param ambig_char The character to use for ambigious positions in the sequence.
#' @param adjust_limit the maximum number of corrections that can be applied to a sequence read. If this number is exceeded 
#' then the entire read is masked with ambigious characters. Default is 5.
#'
outseq = function(x, ...){
  UseMethod("outseq")
}

#' @rdname outseq
#' @export
outseq.DNAseq = function(x, keep_flanks = TRUE, ambig_char = "N", adjust_limit = 5){
  
  if(keep_flanks == TRUE){
    
    dashes_rm = sum(c(length(x$frame_dat$front), as.integer(x$data$len_first_front), 1), na.rm = TRUE)
    if(dashes_rm > length(x$adjusted_sequence)){
      x$adjusted_sequence=NULL
    }
    
    #here the good part of the read is pasted back together with the flanking information
    #that was omitted.
    x$outseq = paste(c(x$data$raw_removed_front, #part removed in front of first frame() call
                       x$frame_dat$removed_lead, #part removed in second frame() call
                       x$adjusted_sequence[dashes_rm:length(x$adjusted_sequence)], #the 'sweet spot' that is denoised
                       x$data$adjusted_trimmed, # part removed in adj_seq
                       x$frame_dat$removed_end, #part removed in second frame() call
                       x$data$raw_removed_end), # part removed from the end of first frame() call
                     collapse = "")
  }else{
    x$outseq = paste(x$adjusted_sequence, collapse = "")
  }
  
  x$outseq = toupper(gsub("-", ambig_char, x$outseq )) 
 
  if(x$adjustment_count > adjust_limit){
    x$outseq = paste(rep(ambig_char, nchar(x$outseq)), collapse = "")
    x$masked = TRUE
  }else{
    x$masked = FALSE
  }
  
  return(x)
}