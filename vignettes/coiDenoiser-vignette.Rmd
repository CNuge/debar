---
title: "coiDenoiser-vignette"
author: "Cameron M. Nugent"
data: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{coiDenoiser-vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup}
library(seqdenoise)
```

## Abstract


## Introduction


## The coiDenoiser Package

### Dependencies
`coiDenoiser` is dependent on [the `aphid` package](https://github.com/shaunpwilkinson/aphid) for comparison of sequences against the COI-5P PHMMs. The `ape` is also a requirement because sequences are internally converted to ape "DNAbin" objects. 

## Example - denoising of circular consensus reads


### The data

For demonstration of the workflow, `coiDenoiser` contains two example files. The first is a fastq file with series of single molecule, real-time (SMRT) sequencing reads generated on the Pacific BioSciences SEQUEL platform. These data are derived from 5 unique samples animal samples, from which 658bp amplicons of the mitochondrial cyctochrom c oxidase I gene were isolated and sequenced. The second file is a .tsv with taxonomic information (on the order and family levels) corresponding to each of the samples. The taxonomic information is not strictly needed for denoising with coiDenoiser, but it greatly increases model performance by allowing for error assessment using taxonomic specific PHMMs (on the order level) as opposed to relying solely on the generic PHMM for the whole tree of life.

```{r}
#example data files 
#for dev:
#fastq_dat_file = './inst/extdata/ccs_subset.fastq'

fastq_dat_file = system.file('extdata/ccs_subset.fastq', package = 'coiDenoiser')
```


### Step 0: quick start

Just show the file-file function and say this is all you need unless you wish to get into the nitty gritty.
```{r}

```

### Step 1: loading and formatting data

The first step in the denoising of the barcode data is loading the files into r and the merger of the datasets based on the unique sample identifiers. `coiDenoiser` contains two functions, `read_fasta` and `read_fastq`, for taking sequence data from standardized file formats and creating dataframes for subsequent denoising.

```{r}
#Build the fastq dataframe
ccs_df = read_fastq(fastq_dat_file)
head(ccs_df)
```

```{r}
?denoise
```


### Step 2: denoisng the sequences 

```{r}
vdenoise = Vectorize(denoise)

start_time = Sys.time()
ccs_list = vdenoise(ccs_df$sequence, ccs_df$header_data,  to_file = FALSE)
end_time = Sys.time()
time_dif = difftime( end_time, start_time, units = "secs")

print(paste("vectorizing the application to the dataframe of", length(ccs_df$sequence), "sequences took:", as.integer(time_dif), "seconds"))
```

```{r}
library("parallel")

start_time = Sys.time()
ccs_list = mclapply(1:length(ccs_df$sequence),  function(i){
  denoise(ccs_df$sequence[i], ccs_df$header_data[i],  to_file = FALSE)},  mc.cores = detectCores())
end_time = Sys.time()
time_dif = difftime( end_time, start_time, units = "secs")
print(paste("multicore applying to the dataframe of", length(ccs_df$sequence), "sequences took:", as.integer(time_dif), "seconds"))

```

```{r}

start_time = Sys.time()
ccs_list = lapply(1:length(ccs_df$sequence), function(i){
  denoise(ccs_df$sequence[i], ccs_df$header_data[i],  to_file = FALSE)
  })
end_time = Sys.time()
time_dif = difftime( end_time, start_time, units = "secs")
print(paste("mapplying to the dataframe of", length(ccs_df$sequence), "sequences took:", as.integer(time_dif), "seconds"))

```


```{r}

ccs_list = list()
start_time = Sys.time()

for(i in 1:length(ccs_df$sequence)){
  ccs_list[[i]] = denoise(ccs_df[[i,'sequence']],
                          ccs_df[[i,'header_data']],
                        	censor_length = 3,
                        	to_file = FALSE)
}


end_time = Sys.time()
time_dif = difftime( end_time, start_time, units = "secs")
print(paste("looping the dataframe of", length(ccs_df$sequence), "sequences took:", as.integer(time_dif), "seconds"))

```


You can access the individual components of the outputs using the dollar sign notation.

```{r}
ccs_list[2]
names(ccs_list[[2]])


```

The parts of the denoise workflow can be executed individually if the users wishes to have more control over the timing and execution of the denoising process.
```{r}

ex_data = DNAseq(ccs_df[[5,'sequence']], name = 'row 5 example')

ex_data = frame(ex_data)
ex_data = adjust(ex_data)

```

### Step 5: outputing the denoised consenus sequences to a file.

The denoise pipeline can be used to output  


```{r}

#can then write the consensus sequece to a fasta or fastq file
#write_fasta(ex_data)
#write_fastq(ex_data)

```


