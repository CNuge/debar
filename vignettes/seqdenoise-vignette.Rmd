---
title: "seqdenoise-vignette"
author: "Cameron M. Nugent"
data: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{seqdenoise-vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup}
library(seqdenoise)
```

## Abstract


## Introduction


## The coiDenoiser Package

### Dependencies
`seqdenoiser` is dependent on [the `aphid` package](https://github.com/shaunpwilkinson/aphid) for comparison of sequences against the COI-5P PHMMs. The `ape` is also a requirement because sequences are internally converted to ape "DNAbin" objects. 


### The data

For demonstration of the workflow, `seqdenoiser` contains several example files. The first is a fastq file with series of single molecule, real-time (SMRT) sequencing reads generated on the Pacific BioSciences SEQUEL platform. These data are derived from 5 unique samples animal samples, from which 658bp amplicons of the mitochondrial cyctochrom c oxidase I gene were isolated and sequenced. 

```{r}
#example data files 
#for dev:
#fastq_dat_file = './inst/extdata/ccs_subset.fastq'

fastq_dat_file = system.file('extdata/ccs_subset.fastq', package = 'seqdenoise')

fastq_real_file = system.file('extdata/sequel_smrt_subset.fastq', package = 'seqdenoise')

fastq_gz_real_file = system.file('extdata/sequel_smrt_subset.fastq.gz', package = 'seqdenoise')

```

```{r}

data = read_fastq(fastq_gz_real_file)
head(data)

```

```{r}
dim(data)
```

```{r}
  dat1 = DNAseq(data$sequence[71], name = 'testseq1' )
  
  dat1 = frame(dat1)
  
  names(dat1)
  
  dat1 = adjust(dat1, censor_length = 5)

  write_fastq(dat1)
  
```

```{r}
x = denoise(data$sequence[71], filename = "out.fastq")
```

```{r}
print(data$sequence[71])
test = denoise(data$sequence[71])
```

```{r}
outputs = list()
for(i in 1:length(data$sequence)){
  print(i)
  #print(data$sequence[i])
  out = denoise(data$sequence[i])
  outputs[[i]] = out
}

length(outputs)
```


```{r}
outputs[[2]]
```

```{r}
denoise_file(fastq_gz_real_file, filename = "out.fastq" )
```





### Step 0: quick start

Just show the file-file function and say this is all you need unless you wish to get into the nitty gritty.

### Step 1: loading and formatting data

The first step in the denoising of the barcode data is loading the files into r and the merger of the datasets based on the unique sample identifiers. `coiDenoiser` contains two functions, `read_fasta` and `read_fastq`, for taking sequence data from standardized file formats and creating dataframes for subsequent denoising.

```{r}
#Build the fastq dataframe
ccs_df = read_fastq(fastq_gz_real_file)
head(ccs_df)
```

```{r}
?denoise
```


### Step 2: denoisng the sequences 

```{r}
vdenoise = Vectorize(denoise)

start_time = Sys.time()
ccs_list = vdenoise(ccs_df$sequence, ccs_df$header_data,  to_file = FALSE)
end_time = Sys.time()
time_dif = difftime( end_time, start_time, units = "secs")

print(paste("vectorizing the application to the dataframe of", length(ccs_df$sequence), "sequences took:", as.integer(time_dif), "seconds"))
```

```{r}
library("parallel")

start_time = Sys.time()
ccs_list = mclapply(1:length(ccs_df$sequence),  function(i){
  denoise(ccs_df$sequence[i], ccs_df$header_data[i],  to_file = FALSE)},  mc.cores = detectCores())
end_time = Sys.time()
time_dif = difftime( end_time, start_time, units = "secs")
print(paste("multicore applying to the dataframe of", length(ccs_df$sequence), "sequences took:", as.integer(time_dif), "seconds"))

```

```{r}

start_time = Sys.time()
ccs_list = lapply(1:length(ccs_df$sequence), function(i){
  denoise(ccs_df$sequence[i], ccs_df$header_data[i],  to_file = FALSE)
  })
end_time = Sys.time()
time_dif = difftime( end_time, start_time, units = "secs")
print(paste("mapplying to the dataframe of", length(ccs_df$sequence), "sequences took:", as.integer(time_dif), "seconds"))

```


```{r}

ccs_list = list()
start_time = Sys.time()

for(i in 1:length(ccs_df$sequence)){
  ccs_list[[i]] = denoise(ccs_df[[i,'sequence']],
                          ccs_df[[i,'header_data']],
                        	censor_length = 3,
                        	to_file = FALSE)
}


end_time = Sys.time()
time_dif = difftime( end_time, start_time, units = "secs")
print(paste("looping the dataframe of", length(ccs_df$sequence), "sequences took:", as.integer(time_dif), "seconds"))

```


You can access the individual components of the outputs using the dollar sign notation.

```{r}
ccs_list[2]
names(ccs_list[[2]])


```

The parts of the denoise workflow can be executed individually if the users wishes to have more control over the timing and execution of the denoising process.
```{r}

ex_data = DNAseq(ccs_df[[5,'sequence']], name = 'row 5 example')

ex_data = frame(ex_data)
ex_data = adjust(ex_data)

```

### Step 5: outputing the denoised consenus sequences to a file.

The denoise pipeline can be used to output  


```{r}

#can then write the consensus sequece to a fasta or fastq file
#write_fasta(ex_data)
#write_fastq(ex_data)

```


