---
title: "seqdenoise-vignette"
author: "Cameron M. Nugent"
data: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{seqdenoise-vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup}
library(seqdenoise)
```

## Abstract


## Introduction


## The coiDenoiser Package

### Dependencies
`coiDenoiser` is dependent on [the `aphid` package](https://github.com/shaunpwilkinson/aphid) for comparison of sequences against the COI-5P PHMMs. The `ape` is also a requirement because sequences are internally converted to ape "DNAbin" objects. 

## Example - denoising of circular consensus reads


### The data

For demonstration of the workflow, `coiDenoiser` contains two example files. The first is a fastq file with series of single molecule, real-time (SMRT) sequencing reads generated on the Pacific BioSciences SEQUEL platform. These data are derived from 5 unique samples animal samples, from which 658bp amplicons of the mitochondrial cyctochrom c oxidase I gene were isolated and sequenced. The second file is a .tsv with taxonomic information (on the order and family levels) corresponding to each of the samples. The taxonomic information is not strictly needed for denoising with coiDenoiser, but it greatly increases model performance by allowing for error assessment using taxonomic specific PHMMs (on the order level) as opposed to relying solely on the generic PHMM for the whole tree of life.

```{r}
#example data files 
#for dev:
#fastq_dat_file = './inst/extdata/ccs_subset.fastq'

fastq_dat_file = system.file('extdata/ccs_subset.fastq', package = 'seqdenoise')

fastq_real_file = system.file('extdata/sequel_smrt_subset.fastq', package = 'seqdenoise')

fastq_gz_real_file = system.file('extdata/sequel_smrt_subset.fastq.gz', package = 'seqdenoise')

```

```{r}

data = read_fastq(fastq_gz_real_file)
head(data)

```

```{r}
dim(data)
```

```{r}
  dat1 = DNAseq(data$sequence[71], name = 'testseq1' )
  
  dat1 = frame(dat1)
  
  names(dat1)
  
  dat1 = adjust(dat1, censor_length = 5)

  write_fastq(dat1)
  
```

```{r}
x = denoise(data$sequence[71], filename = "out.fastq")
```

```{r}
print(data$sequence[71])
test = denoise(data$sequence[71])
```

```{r}
outputs = list()
for(i in 1:length(data$sequence)){
  print(i)
  #print(data$sequence[i])
  out = denoise(data$sequence[i])
  outputs[[i]] = out
}

length(outputs)
```


```{r}
outputs[[2]]
```

```{r}
denoise_file(fastq_gz_real_file, filename = "out.fastq" )
```


## Tests using select outputs from the real data analysis

```{r}

t1 = "gctcctaaaattgaagaaactcctgctaaatgtaaagaaaaaattgctaaatctactgaagcaccaccatgagcaataatagaagataaaggtggataaacagttcatccagtaccagccccattttctactatacttctagccattaatagagtcaatgaaggcggtaataatcagaaactcatattatttattcgaggaaatgctatatccggagctcctaatattaatggaactaatcaatttccaaatcctccaattataattggtattactataaaaaaaattattacgaaagcatgggcagtgacaattacattataaatttgatcatcaccaattaatgctcctggatgtcctaattcagctcgaattaagattcttagagaagttcctactattccagctcatgctccaaatataaagtacaaagttccaatatctttatgattggttgactgtgacctgagtcagctacatgttcgactgcatagacagtgcgctgtctatgcagtcgaacatgtagctgactcaggtcacggtcaacaaatcataaagatattggaactttgtactttatatttggagcatgagctggaatagtaggaacttctctaagaatcttaattcgagctgaattaggacatccaggagcattaattggtgatgatcaaatttataatgtaattgtcactgcccatgctttcgtaataatttttttatagtaataccaattataattggaggatttggaaattgattagttccattaatattaggagctccagatatagcatttcctcgaataaataatatgagtctctgattattaccgccttcattgactctattaatggctagaagtatagtagaaaatggggctggtactggatgaactgtttatccacctttatcttctattattgctcatggtggtgcttcagtagatttagcaattttttctttacatttagcaggagtttcttcaattttaggagc"


test_seqdenoise = DNAseq(t1, name = "test1")
test_seqdenoise = frame(test_seqdenoise)
test_seqdenoise$data$path
test_seqdenoise$data$raw_removed_front
z = adjust(test_seqdenoise)
test_seqdenoise$adjustment_count
#test_seqdenoise = seqdenoise::frame(test_seqdenoise)
#test_seqdenoise$data$path
```

```{r}
#issue here, the 296 characters outside of the denoised area are dropped
#i.e. after the run of 2s happens, all of the following data is omitted in the subsequent output.
#need adjust seq to keep these parts on the edges, find the logic that ceases the iteration if 
# a large string of 1s or twos is encountered... consider how to proceed given that the later
#example, t3 is benefitting from the trunction at this early point.
t2 = "CGTATGTATGTCGCGCAGTCGAACATGTAGCTGACTCAGGTCACGGTCAACAAATCATAAAGATATTGGAACTTTATATTTTATTTTTGGAATTTGAGCAGGAATAGTAGGAACTTCTTTAAGTTTATTAATTCGACTTGAATTAAGAACAATAAAAAATTTAATTGGTAATGATCAAATTTATAATGTAATTGTTACAGCCCACGCATTTATTATAATTTTTTTTATAGTTATACCAATTTTAATTGGAGGATTTGGAAATTGATTAGTCCCTATTATATTAGGAGCCCCAGATATAGCTTTTCCACGAATAAATAATATAAGATTCTGAATATTACCCCCTTCTTTATCTTTACTATCAATTAGAAGAATAGTAGAAACTGGGACCGGAACAGGATGAACTGTTTACCCACCTCTTTCTTCTGTAATTGCACATACTGGATCTTCAGTAGATTTTTCAATTTTTTCTCTACATATTGCAGGAATTTCATCTATTTTAGGAGCAATTAATTTTATTTCTACAATAATAAATATAAAAATTGAAAAATCTACTGAAGATCCAGTATGTGCAATTACAGAAGAAAGAGGTGGGTAAACAGTTCATCCTGTTCCGGTCCCAGTTTCTACTATTCTTCTAATTAATAGTAAAGATAAAGAAGGGGGTAATATTCAGAATCTTATATTATTTATTCGTGGAAAAGCTATATCTGGGGCTCCTAATATAATAGGGACTAATCAATTTCCAAATCCTCCAATTAAAATTGGTATAACTATAAAAAAAAATTATAATAAATGCGTGGGCTGTAACAATTACATTATAAATTTGATCATTACCAATTAAATTTTTTATTGTTCTTAATTCAAGTCGAATTAATAAACTTAAAGAAGTTCCTACTATTCCTGCTCAAATTCCAAAAATAAAATATAAAGTTCCAATATCTTTATGATTGGTTGAATGTGACCTGAGTCAGCTACATGTTCGACTGCGCGACATACATACG"
test_seqdenoise2 = DNAseq(t2, name = "test1")
test_seqdenoise2 = frame(test_seqdenoise2)
test_seqdenoise2$data$path
test_seqdenoise2$data$raw_removed_front
test_seqdenoise2$data$raw_removed_end
test_seqdenoise2 = adjust(test_seqdenoise2)
test_seqdenoise2$adjusted_sequence
test_seqdenoise2 = outseq(test_seqdenoise2)
test_seqdenoise2$outseq
```


 Coil produces a path with ~433 matches and a single insert. suggests the logic issue is in the seqdenoise frame
```{r}
#library(coil)
t1 = "gctcctaaaattgaagaaactcctgctaaatgtaaagaaaaaattgctaaatctactgaagcaccaccatgagcaataatagaagataaaggtggataaacagttcatccagtaccagccccattttctactatacttctagccattaatagagtcaatgaaggcggtaataatcagaaactcatattatttattcgaggaaatgctatatccggagctcctaatattaatggaactaatcaatttccaaatcctccaattataattggtattactataaaaaaaattattacgaaagcatgggcagtgacaattacattataaatttgatcatcaccaattaatgctcctggatgtcctaattcagctcgaattaagattcttagagaagttcctactattccagctcatgctccaaatataaagtacaaagttccaatatctttatgattggttgactgtgacctgagtcagctacatgttcgactgcatagacagtgcgctgtctatgcagtcgaacatgtagctgactcaggtcacggtcaacaaatcataaagatattggaactttgtactttatatttggagcatgagctggaatagtaggaacttctctaagaatcttaattcgagctgaattaggacatccaggagcattaattggtgatgatcaaatttataatgtaattgtcactgcccatgctttcgtaataatttttttatagtaataccaattataattggaggatttggaaattgattagttccattaatattaggagctccagatatagcatttcctcgaataaataatatgagtctctgattattaccgccttcattgactctattaatggctagaagtatagtagaaaatggggctggtactggatgaactgtttatccacctttatcttctattattgctcatggtggtgcttcagtagatttagcaattttttctttacatttagcaggagtttcttcaattttaggagc"

coil_test = coi5p_pipe(t1)
coil_test$data$ntPath
coil_test$raw
coil_test$framed
coil_test

```

```{r}

coil_test_parts = coi5p(t1)
coil_test_parts = frame(coil_test_parts)

coil_test_parts$framed
coil_test_parts$data$ntPath
```


```{r}
t3 = 'AGGTCAACAAATCATAAAGATATTGGAACATTATATTTTTTATTTGGAATTTGAGCAGGAATAATTGGAACATCATTAAGATTATTAATTCGAATAGAATTAGGAAATCCTGGATCCTTAATTGGAGATGACCAAATTTATAATAACTATTGTAAACAGCCCATGCATTTATTATAATTTTTTTTATAGTAATACCTATTATAATTGGAGGATTTGGAAATTGATTAATTCCTTTAATATTAGGTGCACCAGATATAGCATTCCCCCGAATAAATAATATAAGATTTTGATTATTACCCCCTTCCATTTTTCTTTTAATTTCAAGAAGAATCGTAGAAAAATGGAGCAGGAACAGGATGAACTGTTTACCCCCCCTTATCTTCTAACACCGCTCATAGAGGAAGATCCGTAGATTTAGCCATTTTTTCTCTTCATTTAGCTGGAATTTCCTCAATTCTAGGAGCAGTAAATTTTATTTCTACAGTAATTAATATACGAGCTAAAAAAATAATATTTGACCAAATACCCCTATTTATTTGAGCTGTAGCTATTACTGCATTATTATTATTATTATCATTACCAGTTTTAGCAGGAGCTATTACTATATTATTAACAGATCGAAATTTAAATACATCTTTTTTTGACCCAGCTGGAGGAGGAGACCCAATTTTATACCAACATTTATTTTGATTTTTTGGACACCCTGAAGTTTA'
```

```{r}
coil_test3  = coi5p_pipe(t3)
coil_test3$data$ntPath
coil_test3$raw
coil_test3$framed
coil_test3
```

```{r}
output_was = 'aggtcaacaaatcataaagatattggaacattatattttttatttggaatttgagcaggaataattggaacatcattaagattattaattcgaatagaattaggaaatcctggatccttaattggagatgaccaaatttataattttgattttttggacaccctgaagttta'
t3
```
Below is behaving well despite initial doubt. The path encounters a large run of 0000s in the middle of the sequence and therefore terminates. Only possible improvement would be to add lots of Ns and pick up on the second run of 1s
```{r}
test_seqdenoise3 = DNAseq(t3, name = "test3")
test_seqdenoise3 = frame(test_seqdenoise3)
test_seqdenoise3$data$path
test_seqdenoise3$data$raw_removed_front
test_seqdenoise3$frame_dat

test_seqdenoise3 = adjust(test_seqdenoise3)
test_seqdenoise3$adjusted_sequence
```
### Step 0: quick start

Just show the file-file function and say this is all you need unless you wish to get into the nitty gritty.

### Step 1: loading and formatting data

The first step in the denoising of the barcode data is loading the files into r and the merger of the datasets based on the unique sample identifiers. `coiDenoiser` contains two functions, `read_fasta` and `read_fastq`, for taking sequence data from standardized file formats and creating dataframes for subsequent denoising.

```{r}
#Build the fastq dataframe
ccs_df = read_fastq(fastq_gz_real_file)
head(ccs_df)
```

```{r}
?denoise
```


### Step 2: denoisng the sequences 

```{r}
vdenoise = Vectorize(denoise)

start_time = Sys.time()
ccs_list = vdenoise(ccs_df$sequence, ccs_df$header_data,  to_file = FALSE)
end_time = Sys.time()
time_dif = difftime( end_time, start_time, units = "secs")

print(paste("vectorizing the application to the dataframe of", length(ccs_df$sequence), "sequences took:", as.integer(time_dif), "seconds"))
```

```{r}
library("parallel")

start_time = Sys.time()
ccs_list = mclapply(1:length(ccs_df$sequence),  function(i){
  denoise(ccs_df$sequence[i], ccs_df$header_data[i],  to_file = FALSE)},  mc.cores = detectCores())
end_time = Sys.time()
time_dif = difftime( end_time, start_time, units = "secs")
print(paste("multicore applying to the dataframe of", length(ccs_df$sequence), "sequences took:", as.integer(time_dif), "seconds"))

```

```{r}

start_time = Sys.time()
ccs_list = lapply(1:length(ccs_df$sequence), function(i){
  denoise(ccs_df$sequence[i], ccs_df$header_data[i],  to_file = FALSE)
  })
end_time = Sys.time()
time_dif = difftime( end_time, start_time, units = "secs")
print(paste("mapplying to the dataframe of", length(ccs_df$sequence), "sequences took:", as.integer(time_dif), "seconds"))

```


```{r}

ccs_list = list()
start_time = Sys.time()

for(i in 1:length(ccs_df$sequence)){
  ccs_list[[i]] = denoise(ccs_df[[i,'sequence']],
                          ccs_df[[i,'header_data']],
                        	censor_length = 3,
                        	to_file = FALSE)
}


end_time = Sys.time()
time_dif = difftime( end_time, start_time, units = "secs")
print(paste("looping the dataframe of", length(ccs_df$sequence), "sequences took:", as.integer(time_dif), "seconds"))

```


You can access the individual components of the outputs using the dollar sign notation.

```{r}
ccs_list[2]
names(ccs_list[[2]])


```

The parts of the denoise workflow can be executed individually if the users wishes to have more control over the timing and execution of the denoising process.
```{r}

ex_data = DNAseq(ccs_df[[5,'sequence']], name = 'row 5 example')

ex_data = frame(ex_data)
ex_data = adjust(ex_data)

```

### Step 5: outputing the denoised consenus sequences to a file.

The denoise pipeline can be used to output  


```{r}

#can then write the consensus sequece to a fasta or fastq file
#write_fasta(ex_data)
#write_fastq(ex_data)

```


