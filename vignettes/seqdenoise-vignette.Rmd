---
title: "DAPR - Denoising Amplicons for PRotein coding markers"
author: "Cameron M. Nugent"
data: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{seqdenoise-vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r loadlib, echo = TRUE, results = 'hide', message=FALSE, warning=FALSE}
library(seqdenoise)
```

## Abstract


## Introduction
preamble here

### Implementation

### Dependencies
`DAPR` is dependent on [the `aphid` package](https://github.com/shaunpwilkinson/aphid) for comparison of sequences against the COI-5P PHMMs. The `ape` is a requirement because sequences are internally converted to `ape` "DNAbin" objects and the package `sequinr` is utilized in obtaining the reverse compliment of input sequences when needed.


### The data

For demonstration of the workflow, `DAPR` contains several example files. The first is a fastq file with series of single molecule, real-time (SMRT) sequencing reads generated on the Pacific BioSciences SEQUEL platform. These data are derived from 5 unique samples animal samples, from which amplicons of the Folmer region of the mitochondrial cyctochrome c oxidase I gene were isolated and sequenced. 

`seqdenoise` is able to operate on inputs from either fasta or fastq files, or their gzipped equivalents. For the vignette, we will use the example file in gzip format.

```{r}
#The following example file is used as an input in the vignette
#also available 
#fastq_example_file = system.file('extdata/sequel_smrt_subset.fastq', package = 'seqdenoise')
fastq_example_file = system.file('extdata/sequel_smrt_subset.fastq.gz', package = 'seqdenoise')

```


## Using the package
### for the impatient
The progam contains a wrapper function `denoise_file` that allows for a user to run the entire denoiser pipeline in a single step (there are quantitatively informed defaults for executing the full pipline, but it is highly reccommended that a user acclimate themselves to the `denoise` pipeline options to ensure that the paramaters make sense for their given dataset and analysis goals).

All that is needed is for the input and output files to be specified. The program by default will read in the input file, run each sequence through the denoising algorithm, and then output the denoised sequences to the specified output file. The denoise pipeline contains certain rules (that a user can control - see below for details on these paramaters) that lead to some sequences being rejected entirely, the `keep_rejects` option allows a user to output these rejected sequences to another file for futher inspection. The program also has an option for generating a simple log file, and allows for multicore execution of the denoising pipeline by simply specify the number of cores the process should utilize. Additionally you can type `?denoise` to see a list of all available denoise paramaters that can be passed to the `denoise_file` wrapper function as well (paramaters are explored in more detail below).
```{r, eval = FALSE}
# NOTE - this block of code is not run so as to avoid the generation of output files!
#
# Our input file with noisy sequence data is fastq_example_file. 
# Output file is "example_output.fastq"
# If you do wish to run these examples, then please double check your working directory!
denoise_file(fastq_example_file, filename = "example_output.fastq")

denoise_file(fastq_example_file,filename = "multicore-example_output.fastq", multicore = 8, log_file = TRUE, keep_rejects = TRUE)

```

Thats all it takes to get `seqdenoise` removing errors from COI barcode data. Below the ins and outs of the program are discussed in more details, to help users make more informed paramater tuning decisions for the denoising of their own data

### Data input

The `read_fasta` and `read_fastq` functions allow users to read data into R for denoising. These functions produce dataframes with columns containing the header data, sequence data and PHRED quality scores (for fastq only - there is an option to discard the quality scores if they are not of interest to the user). 

```{r}
data = read_fastq(fastq_example_file)
names(data)
#head(data) - to view the first few records
```

## Denoiser pipeline - components and walkthrough
*explain that here it is demonstrated on a single sequence, step by step. all paramaters for these individual componenets can be passed to the `denoise` function to control the operation in a single step.


### Building a DNAseq object

The `DAPR` denoising pipeline is built around the custom `DNAseq` object, which is used to store the input sequence data and the outputs generated by the denoising process.

`ex` will store a DNAseq object, with the raw sequence, the name of the sequence (in this case the read id) and optionally the PHRED quality scores as well.

```{r}
i = 33 #the row number from the example dataframe to be analyzed in the single sequence demonstration
ex = DNAseq(data$sequence[[i]], name = data$header_data[[i]], phred = data$quality[[i]])
ex #
```
The raw sequence, phred score and name can then be accessed through the dollar sign notation. As data are generated by the denoising process, they can also be accessed using this notation.
```{r}
ex$name
#can always check to see the available components with the names function
print("Available in the current DNAseq object:")
names(ex)
```

### Checking sequence quality with Phred scores (optional)

If you're denoising data from a fastq file, you may wish to utilize the `phred_check` function as well. This function can help separate out low quality reads from a dataset in an efficient manner. Instead of running every single sequence through the statistical models used for denoising, this pre-check can be used to remove sequences with quality values not eclipsing the given thresholds. The quality thresholds filter reads if they do not meet a minimum average phred score (`min_avg_qv`), if the frequence of low quality reads (QV < 20) is too high (`max_perc_low`) or if the frequency of ultra low quality reads (QV <10) is too high (`max_perc_ultra_low`). If these thresholds are eclipsed, the `DNAseq` object's `reject` field will be `TRUE`.

```{r}
#run the phred_check with the default paramaters
ex = phred_check(ex)

ex$reject #this read meets the phred_check thresholds, so it should not be rejected based on this information
```


### Framing the barcode sequence
The `frame` function is one of the two main workhorses in the denoising pipeline. It takes the raw data sequence and compares it against the nucleotide profile hidden Markov model (PHMM), generating the statistical information (The Viterbi algorithm's output path) that is used to apply corrections to the sequence read. Since the PHMM is a profile of only the 657bp region of COI-5P (and not capable of denoising surrounding data) it also takes the input sequence and removes any flanking regions that fall outside of the 657bp COI-5P region. Don't worry though, if you wish to keep these parts of your sequence, there is an option to include the removed flanking sequences in the output (you may want these if they contian important identifying information, i.e. tags to relate multiplexed reads back to their sample of origin). Just be aware that if you do keep the flaking regions, any errors in these regions will go uncorrected!

By default, the `frame` function will compare both the forward and reverse compliments of an input read to the PHMM and use the log likelihood values to pick the direction that best matches the COI-5P profile. If you are confident that all reads being denoised are in the forward oritentation, then you can speed up the frame function by setting the optionL `dir_check = FALSE` (in this case `frame` will not generate the reverse compliment, and only pass the sequence through the PHMM in the forwad orientation). Additionally `frame` contains an additional set of options that can be use to filter out small fragments and potential chimeric sequences. When the `terminate_rejects` option is set to `TRUE` then the following two checks are run: (1) checks to see if a sequence contains more than `max_inserts` (default = 400) consecutive insert states in the PHMM path (i.e. 400 or more consecutive bp in the sequence appear to *not* be part of COI-5P) (2) checks if the sequence contains less than `min_match`(default = 100) consecutive matches to the PHMM. If either condition is met the sequence will be flagged for rejection and not framed. 

```{r}
ex = frame(ex)
```
#TODO - explain the terminate rejects option better in the documentation. explicitly state that the min_match only comes into effect if the terminate rejects option is on.

### Adjusting the sequence

The `adjust` function is the component of the denoising pipeline where identified errors in the sequence are corrected. Using the PHMM path output and the information about the framing of the sequence generated by the `frame` function, adjust applies insertion and deletion corrections to the DNA sequence. The series hidden match, insert and delete states in the PHMM path are assessed and used to correct the DNA sequence. Certain rules are applied in the adjustment algorithm to ensure that adjustments are not being applied to highly erroneous sequences, or sequences with deviations from the expected COI structure that may be biologically true. First, triple inserts or triple deletes (3 consecutive nucleotides missing or added) are not corrected by the adjust algorithm. This is because the insertion or deletion of a codon would preserve the integrity of the amino acid sequence (no frame shift). In fact, certain species do possess COI-5P sequences with full codons missing (i.e. they are 654bp in length); adjustments of sequences of this kind would be erroneous. Additionally, if 5 or more consecutive insert or delete states are encountered, the adjustment is ceased and the sequence is flagged for rejection. Drastic deviations of this kind are extremly improbable and indicative of a larger problem with the sequence than simply minor technical errors (i.e. a contanimant sequnece or chimera).

  In addition to the DNAseq class object, two other paramaters are accepted by the `adjust` function. `censor_length` is the paramater used to determine the number of base pairs adjacent to a correction that should be covered up (turned into placeholder characters). This paramater exists because the comparison of sequences to the PHMM via the Viterbi algorithm is not perfect in its identification of the location of indel errors. Censoring base pairs adjacent to the correction applied can increase the probability that the erroneous base pair is remove from a sequence, but comes at the tradeoff of a loss of information in the read (this limitation is overcome when multiple sequence ouputs from a given sample are avalaible). The adjustment corrects the length of the sequence (the erronous bp is removed when an insertion is identified and a placeholder character is added when a deletion is identified) and censorship maximizes the likelihood of the error being removed. The default `censor_length` is 7 (i.e. seven bases left or right of an indel adjustment are turned into placeholder charcters). This number is not arbritrary, but rather was determined through experimental corrections. In the denoising of a series of 10K barcode sequences each with a single artifical indel error with known position 61.8% of errors were corrected exactly. 38.2% of the time, errors were incorrectly reported by an average of 2.31bp (standard deviation=1.98). 

  A conservative censorship size of 7 was decided upon by analysis of the mean miss distance (and standard deviation) in only the incorrect adjustments. The mean plus two standard deviations (2.3 + (2*1.98) = 6.26) was rounded up, based on the test results this would lead to the censorship of greater than 95% of errors that were not correctly identified by the PHMM. This explination is given to the user to inform any potential decisions about altering the censorship length. The default is highly conservative as the summary statistics used to calulate the length omit the 61.8% of the time that corrections were applied exactly. The use can make the censorship of reads as conservative as they wish (`censor_length` = 657 would mask a read showing a single bp deviation from the COI profile) or disable this feature (`censor_length` = 0) and accept all corrections made by the `adjust` algorithm.

  The 

```{r}
ex = adjust(ex, censor_length = 4)
```

The algorithm keeps track of the number of adjustments made
```{r}
ex$adjustment_count
```

The PHMM suggests a bp was missing at position 157 in the profile (the path can be called directly via dollar sign notation `ex$data$path`). A placeholder (character is a '-' until the final `outseq` step) is inserted and since `adjust` was given the paramater `censor_length = 4` four base pairs in either side of the correction are also turned into placeholders. Note that since `added_phred` was left as its default, the inserted bp has a phred score of `*` (as indicated by the labels shown above the adjusted sequence characters).
```{r}
ex$adjusted_sequence[150:164]
```

### Amino Acid check


### Creating the output sequence



### Writing the 




## Batch analyses in R




```{r}
dim(data)
```

```{r}
x = denoise(data$sequence[[71]], keep_phred = FALSE, to_file = FALSE)
x

```

```{r}
x = denoise(data$sequence[[78]], phred = data$quality[[78]])
x

```

```{r}
x = DNAseq(data$sequence[[71]], name = 'test1')

```

```{r}

test = denoise(data$sequence[[71]], to_file = FALSE)
```

```{r}
outputs = list()
for(i in 1:15){
  print(i)
  #print(data$sequence[i])
  out = denoise(data$sequence[i], name = data$header_data[i], phred = data$quality[i], to_file = FALSE )
  outputs[[i]] = out
}

print("output length:")
length(outputs)
```


```{r}
outputs[[2]]
```





