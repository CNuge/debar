---
title: "DAPR - Denoising Amplicons for PRotein coding markers"
author: "Cameron M. Nugent"
data: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{seqdenoise-vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r loadlib, echo = TRUE, results = 'hide', message=FALSE, warning=FALSE}
library(seqdenoise)
```

## Abstract


## Introduction
preamble here

### Implementation

### Dependencies
`DAPR` is dependent on [the `aphid` package](https://github.com/shaunpwilkinson/aphid) for comparison of sequences against the COI-5P PHMMs. The `ape` is also a requirement because sequences are internally converted to `ape` "DNAbin" objects. 


### The data

For demonstration of the workflow, `DAPR` contains several example files. The first is a fastq file with series of single molecule, real-time (SMRT) sequencing reads generated on the Pacific BioSciences SEQUEL platform. These data are derived from 5 unique samples animal samples, from which amplicons of the Folmer region of the mitochondrial cyctochrome c oxidase I gene were isolated and sequenced. 

`seqdenoise` is able to operate on inputs from either fasta or fastq files, or their gzipped equivalents. For the vignette e

```{r}
#The following example file is used as an input in the vignette
#also available 
#fastq_example_file = system.file('extdata/sequel_smrt_subset.fastq', package = 'seqdenoise')
fastq_example_file = system.file('extdata/sequel_smrt_subset.fastq.gz', package = 'seqdenoise')

```


## Using the package
### for the impatient
The progam contains a wrapper function `denoise_file` that allows for a user to run the entire denoiser pipeline in a single step (there are quantitatively informed defaults for executing the full pipline, but it is highly reccommended that a user acclimate themselves to the `denoise` pipeline options to ensure that the paramaters make sense for their given dataset and analysis goals).

All that is needed is for the input and output files to be specified. The program by default will read in the input file, run each sequence through the denoising algorithm, and then output the denoised sequences to the specified output file. The denoise pipeline contains certain rules (that a user can control - see below for details on these paramaters) that lead to some sequences being rejected entirely, the `keep_rejects` option allows a user to output these rejected sequences to another file for futher inspection. The program also has an option for generating a simple log file, and allows for multicore execution of the denoising pipeline by simply specify the number of cores the process should utilize. Additionally you can type `?denoise` to see a list of all available denoise paramaters that can be passed to the `denoise_file` wrapper function as well (paramaters are explored in more detail below).
```{r, eval = FALSE}
# NOTE - this block of code is not run so as to avoid the generation of output files!
#
# Our input file with noisy sequence data is fastq_example_file. 
# Output file is "example_output.fastq"
# If you do wish to run these examples, then please double check your working directory!
denoise_file(fastq_example_file, filename = "example_output.fastq")

denoise_file(fastq_example_file,filename = "multicore-example_output.fastq", multicore = 8, log_file = TRUE, keep_rejects = TRUE )

```

Thats all it takes to get `seqdenoise` removing errors from COI barcode data. Below the ins and outs of the program are discussed in more details, to help users make more informed paramater tuning decisions for the denoising of their own data

### Data input

The `read_fasta` and `read_fastq` functions allow users to read data into R for denoising. These functions produce dataframes with columns containing the header data, sequence data and PHRED quality scores (for fastq only - there is an option to discard the quality scores if they are not of interest to the user). 

```{r}
data = read_fastq(fastq_example_file)
names(data)
#head(data) - to view the first few records
```

## Denoiser pipeline - components and walkthrough
*explain that here it is demonstrated on a single sequence, step by step. all paramaters for these individual componenets can be passed to the `denoise` function to control the operation in a single step.


### Building a DNAseq object

ex will store a DNAseq object, with the raw sequence, the name of the sequence (in this case the read id) and optionally the PHRED quality scores as well.

```{r}
i = 71 #the row number from the example dataframe to be analyzed in the single sequence demonstration
ex = DNAseq(data$sequence[[i]], name = data$header_data[[i]], phred = data$quality[[i]])
ex #
```


### Checking sequence quality with Phred scores (optional)
If you're denoising data from a fastq file, you may wish to utilize the `phred_check` function as well. This function can help separate out low quality reads from a dataset in an efficient manner. Instead of running every single sequence through the statistical models used for denoising, this pre-check can be used to remove sequences with quality values not eclipsing the given thresholds. The quality thresholds filter reads if they do not meet a minimum average phred score (`min_avg_qv`), if the frequence of low quality reads (QV < 20) is too high (`max_perc_low`) or if the frequency of ultra low quality reads (QV <10) is too high (`max_perc_ultra_low`). If these thresholds are eclipsed, the `DNAseq` object's `reject` field will be `TRUE`.

```{r}
#run the phred_check with the default paramaters
ex = phred_check(ex)

ex$reject #this read meets the phred_check thresholds, so it should not be rejected based on this information
```


### Framing the barcode sequence


```{r}


```


### Adjusting the sequence


### Amino Acid check


### Creating the output sequence



### Writing the 




## Batch analyses in R




```{r}
dim(data)
```

```{r}
x = denoise(data$sequence[[71]], keep_phred = FALSE, to_file = FALSE)
x

```

```{r}
x = denoise(data$sequence[[78]], phred = data$quality[[78]])
x

```

```{r}
x = DNAseq(data$sequence[[71]], name = 'test1')

```

```{r}

test = denoise(data$sequence[[71]], to_file = FALSE)
```

```{r}
outputs = list()
for(i in 1:15){
  print(i)
  #print(data$sequence[i])
  out = denoise(data$sequence[i], name = data$header_data[i], phred = data$quality[i], to_file = FALSE )
  outputs[[i]] = out
}

print("output length:")
length(outputs)
```


```{r}
outputs[[2]]
```





